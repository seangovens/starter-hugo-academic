@InProceedings{ovens:LIPIcs.DISC.2022.30,
  author =	{Ovens, Sean},
  title =	{{The Space Complexity of Scannable Objects with Bounded Components}},
  booktitle =	{36th International Symposium on Distributed Computing (DISC 2022)},
  pages =	{30:1--30:18},
  series =	{Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN =	{978-3-95977-255-6},
  ISSN =	{1868-8969},
  year =	{2022},
  volume =	{246},
  editor =	{Scheideler, Christian},
  publisher =	{Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address =	{Dagstuhl, Germany},
  URL =		{https://drops.dagstuhl.de/opus/volltexte/2022/17221},
  URN =		{urn:nbn:de:0030-drops-172213},
  doi =		{10.4230/LIPIcs.DISC.2022.30},
  annote =	{Keywords: space complexity, lower bound, shared memory, snapshot object}
}

@inproceedings{10.1145/3519270.3538420,
author = {Ovens, Sean},
title = {The Space Complexity of Consensus from Swap},
year = {2022},
isbn = {9781450392624},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3519270.3538420},
doi = {10.1145/3519270.3538420},
abstract = {Nearly thirty years ago, it was shown that Ω(√n ) read/write registers are needed to solve obstruction-free consensus among n processes. This lower bound was improved to n registers in 2018, which exactly matches the best upper bound. The \O{}mega (√n) space complexity lower bound actually applies to a class of objects called historyless objects, which includes read/write registers, test-and-set objects, and readable swap objects. However, every known n-process obstruction-free consensus algorithm from historyless objects uses Ω(n) objects.In this paper, we give the first Ω(n) space complexity lower bounds for two kinds of historyless objects. First, we show that any obstruction-free consensus algorithm from swap objects uses at least n-1 objects. We also present an obstruction-free consensus algorithm from n-1 swap objects, exactly matching our lower bound. To our knowledge, this is the first consensus algorithm from swap objects that do not also support the Read operation.Second, we show that any obstruction-free binary consensus algorithm from readable binary swap objects uses at least n - 2 objects. The best known obstruction-free binary consensus algorithm from readable binary swap objects uses 2n-1 objects, which shows that our lower bound is asymptotically tight. Since any historyless object can be simulated by a readable swap object with the same domain, our results imply that any obstruction-free consensus algorithm from binary historyless objects uses at least n - 2 objects.},
booktitle = {Proceedings of the 2022 ACM Symposium on Principles of Distributed Computing},
pages = {176–186},
numpages = {11},
keywords = {consensus, shared memory, lower bounds, space complexity},
location = {Salerno, Italy},
series = {PODC'22}
}

@inproceedings{10.1145/3465084.3467916,
author = {Ovens, Sean},
title = {The Space Complexity of Scannable Binary Objects},
year = {2021},
isbn = {9781450385480},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3465084.3467916},
doi = {10.1145/3465084.3467916},
abstract = {Determining a consistent view of the contents of a shared array while its components are being modified is a fundamental task in distributed algorithm design. Snapshot objects address this problem when read/write registers are components of the array. A natural generalization of a snapshot object is a scannable object, an object with multiple components that each support Read and some other operations. Scannable objects also support the Scan operation, which provides an instantaneous view of all the object's components. This raises the question: How many instances of objects in some set O are required to implement a scannable object whose components are in O In this paper, we consider scannable binary objects, whose components are arbitrary 1-bit objects. If each component is a test-and-set object, there is a simple implementation using k test-and-set objects. However, when each component is non-monotonic (i.e. can change from 0 to 1 and from 1 to 0), we prove that more objects are needed. Specifically, when n ≤ 2^k-1 + 2, we show a lower bound of n + k - 2 base objects, even for obstruction-free, single-updater implementations. When n ≥ 2^k-2, we prove that 2^k-1 base objects are required for obstruction-free, single-updater implementations. When 2^k-1 +2 &lt; n &lt; 2^k-2, we show a gradual transition between these two lower bounds. We show that there is a lock-free implementation of an n-process, scannable binary object with k components from n + k instances of 1-bit base objects, nearly matching our lower bound when n \l{}eq 2^k-1 + 2. There is a known wait-free, single-updater implementation that uses 2^k base objects, nearly matching our lower bound when n ≥ 2^k-2.},
booktitle = {Proceedings of the 2021 ACM Symposium on Principles of Distributed Computing},
pages = {509–519},
numpages = {11},
keywords = {lower bound, shared memory, space complexity, snapshot object},
location = {Virtual Event, Italy},
series = {PODC'21}
}

@inproceedings{10.1145/3293611.3331632,
author = {Ovens, Sean and Woelfel, Philipp},
title = {Strongly Linearizable Implementations of Snapshots and Other Types},
year = {2019},
isbn = {9781450362177},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3293611.3331632},
doi = {10.1145/3293611.3331632},
abstract = {Linearizability is the gold standard of correctness conditions for shared memory algorithms, and historically has been considered the practical equivalent of atomicity. However, it has been shown that replacing atomic objects with linearizable implementations can affect the probability distribution of execution outcomes in randomized algorithms. Thus, linearizable objects are not always suitable replacements for atomic objects. A stricter correctness condition called strong linearizability has been developed and shown to be appropriate for randomized algorithms in a strong adaptive adversary model[16].We devise several new lock-free strongly linearizable implementations from atomic registers. In particular, we give the first strongly linearizable lock-free snapshot implementation that uses bounded space. This improves on the unbounded space solution of Denysyuk and Woelfel[14]. As a building block, our algorithm uses a lock-free strongly linearizable ABA-detecting register. We obtain this object by modifying the wait-free linearizable ABA-detecting register of Aghazadeh and Woelfel [5], which, as we show, is not strongly linearizable.Aspnes and Herlihy[8] identified a wide class of types that have wait-free linearizable implementations. These types require that any pair of operations either commute, or one overwrites the other. Aspnes and Herlihy gave a general wait-free linearizable implementation of such types, employing an atomic snapshot object. We show that this implementation is strongly linearizable, proving that all types in this class have a lock-free strongly linearizable implementation from atomic registers.},
booktitle = {Proceedings of the 2019 ACM Symposium on Principles of Distributed Computing},
pages = {197–206},
numpages = {10},
keywords = {distributed algorithms, snapshots, shared memory, lock-freedom, strong linearizability, aba},
location = {Toronto ON, Canada},
series = {PODC '19}
}

@misc{https://prism.ucalgary.ca/handle/1880/110755,
  title = {Strongly Linearizable Implementations of Fundamental Primitives},
  author = {Ovens, Sean},
  year = {2019},
  URL = {https://prism.ucalgary.ca/handle/1880/110755},
  doi = {10.11575/PRISM/10182},
  publisher = {PRISM}
}
